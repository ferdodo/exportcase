use crate::{
    rule_filename_matches_export::rule_filename_matches_export,
    rule_single_named_export::rule_single_named_export,
    rule_star_export_index::rule_star_export_index,
    rule_result::RuleResult,
    read_ts_exports::read_ts_exports,
    wasi_src_file_repository::WasiSrcFileRepository,
    src_file_repository::SrcFileRepository,
    src_file::SrcFile
};
use std::path::Path;
use std::process;

fn create_file_iterator(
    directory: Option<String>, 
    files: Option<Vec<String>>
) -> Box<dyn Iterator<Item = Result<SrcFile, String>>> {
    let repository = WasiSrcFileRepository;
    
    match (directory, files) {
        (Some(dir), None) => {
            println!("# Processing directory: {}", &dir);
            let files = repository.iterate_src_files(&dir);
            Box::new(files.into_iter().map(|r| r.map_err(|e| e.to_string())))
        },
        (None, Some(file_list)) => {
            println!("# Processing specific files:");
            for file in &file_list { println!("#   - {}", file); }
            Box::new(file_list.into_iter().map(move |file_path| {
                if Path::new(&file_path).exists() {
                    repository.load_src_file(&file_path).map_err(|e| e.to_string())
                } else {
                    Err(format!("File not found: {}", file_path))
                }
            }))
        },
        (Some(dir), Some(file_list)) => {
            println!("# Processing directory: {} and specific files:", &dir);
            for file in &file_list { println!("#   - {}", file); }
            
            let dir_files = repository.iterate_src_files(&dir);
            let specific_files = file_list.into_iter().map(move |file_path| {
                if Path::new(&file_path).exists() {
                    repository.load_src_file(&file_path).map_err(|e| e.to_string())
                } else {
                    Err(format!("File not found: {}", file_path))
                }
            });
            
            Box::new(dir_files.into_iter().map(|r| r.map_err(|e| e.to_string())).chain(specific_files))
        },
        (None, None) => {
            eprintln!("Error: Either a directory or specific files must be provided");
            process::exit(1);
        }
    }
}

pub fn format_command(directory: Option<String>, files: Option<Vec<String>>) {
    println!("#!/bin/bash\n");
    println!("# Script generated by exportcase to rename files according to their exports");
    println!("# Files that cannot be automatically renamed are listed below\n");
    
    let src_files = create_file_iterator(directory, files);
    let mut skipped_files = Vec::new();
    let mut renamed_files = Vec::new();
    let mut correctly_named_count = 0;
    
    for file_result in src_files {
        match file_result {
            Ok(file) => {
                let exports_result = read_ts_exports(&file);
                
                match exports_result {
                    Ok(exports) => {
                        let rules = [
                            rule_single_named_export(&exports, &file),
                            rule_star_export_index(&exports, &file),
                        ];
                        
                        let mut has_other_errors = false;
                        for rule in &rules {
                            if let RuleResult::Error(_) = rule {
                                has_other_errors = true;
                                break;
                            }
                        }
                        
                        if has_other_errors {
                            skipped_files.push(format!("{}: Has multiple exports or other issues", file.path));
                            continue;
                        }
                        
                        if let RuleResult::Error(_) = rule_filename_matches_export(&exports, &file) {
                            if let Some(named_export) = exports.named_exports.first() {
                                let is_tsx = file.path.to_lowercase().ends_with(".tsx");
                                let new_name = format!("{}.{}", named_export, if is_tsx { "tsx" } else { "ts" });
                                let new_path = Path::new(&file.path)
                                    .with_file_name(&new_name)
                                    .to_string_lossy()
                                    .to_string();
                                
                                if !Path::new(&new_path).exists() {
                                    println!("mv {} {}", file.path, new_path);
                                    renamed_files.push(format!("{} -> {}", file.path, new_path));
                                } else {
                                    skipped_files.push(format!("{}: Destination file already exists ({})", file.path, new_path));
                                }
                            } else {
                                skipped_files.push(format!("{}: No named exports found", file.path));
                            }
                        } else {
                            correctly_named_count += 1;
                        }
                    },
                    Err(err) => {
                        skipped_files.push(format!("{}: Error analyzing exports: {}", file.path, err));
                    }
                }
            },
            Err(err) => {
                skipped_files.push(format!("Error loading file: {}", err));
            }
        }
    }
    
    if !skipped_files.is_empty() {
        println!("\n# Files that could not be automatically renamed:");
        for file in &skipped_files {
            println!("# {}", file);
        }
    }
    
    println!("\n# Summary:");
    println!("# {} files will be renamed", renamed_files.len());
    println!("# {} files were skipped", skipped_files.len());
    println!("# {} files are already correctly named", correctly_named_count);
} 